#### Complejidad ####

/*
Â¿QuÃ© es un problema de clase P?   // No es lo mismo lenguaje que problema
*/

Un problema de clase P es un problema que es decidible en tiempo polinomial mediante una MÃ¡quina de Turing determinista de una cinta.
Dado un lenguaje ğ¿, existe una MÃ¡quina de Turing determinista que decide si una cadena ğ‘¤ pertenece a ğ¿ en tiempo polinomial.

La clase P es invariante a los modelos de computacion que puedan simularse en tiempo polinomial en MT de una cinta.

/*
Â¿QuÃ© es un problema de clase NP?
*/

Un problema de clase NP es un problema que es decidible en tiempo polinomial mediante una MÃ¡quina de Turing no determinista.


/*
Â¿QuÃ© es un verificador de un lenguaje?
*/

Un verificador de un lenguaje es un algoritmo que permite saber si una cadena pertenece al lenguaje.
Es decir, una cadena w pertenece al lenguaje A si existe una cadena c tal que el algoritmo V acepta el par âŸ¨w,câŸ©
A = {w âˆ£ V acepta âŸ¨w,câŸ© para alguna cadena c}

Un lenguaje A es verificable polinomialmente si existe un verificador en tiempo polinomial para A.



/*
Demuestre que un lenguaje A es NP si y solo si es verificable polinomialmente.
*/

DemostraciÃ³n: (<-)
Si A es verificable polinomialmente, entonces existe un verificador V en tiempo polinomial O(n^k). 
Podemos construir una MÃ¡quina de Turing indeterminista en tiempo polinomial de la siguiente forma:
Dada w de longitud n:
 1.- Generar de forma indeterminista una cadena c de longitud mÃ¡xima n^k.
 2.- Ejecutar V sobre <w,c>
 3.- Si V acepta, aceptar. Si no, rechazar.


DemostraciÃ³n: (->)
Si A es NP entonces existe una MÃ¡quina de Turing no determinista que decide en tiempo polinomial O(n^k). 
Podemos construir un verificador V en tiempo polinomial O(n^k) de la siguiente forma:
Dadas <w,c> :
 1.- Ejecutar MT sobre w, tratando cada sÃ­mbolo de c como la elecciÃ³n de cada paso indeterminista de MT.
 2.- Si el camino seleccionado por c acepta w, aceptar. Si no, rechazar.



/*
Â¿QuÃ© es un lenguaje NP-Completo?
*/

Los problemas NP-completo son problemas NP que, si tuvieran soluciÃ³n en tiempo polinomial, permitirÃ­an demostrar que todos los problemas NP tienen soluciÃ³n en tiempo polinomial.
- Si algÃºn problema NP no tiene soluciÃ³n polinomial, entonces ningÃºn problema NP-completo tiene.
- Si algÃºn problema NP-completo tiene soluciÃ³n polinomial, entonces todos los problemas NP tienen.



/*
Enuncie el Teorema de Cook y Levin y describa su demostraciÃ³n
*/

Sea SAT el lenguaje formado por las fÃ³rmulas booleanas satisfactibles, es decir, que existan valores que hacen cierta a la fÃ³rmula.
El Teorema de Cook y Levin establece que el lenguaje SAT pertenece a la clase P si y solo si P = NP. Es decir, SAT es un problema NP-Completo y por tanto 
existe un verificador que verifica SAT en tiempo polinomial (tabla de verdad).
El teorema plante un tablero de configuraciÃ³n en el que si se alcanza un estado de aceptaciÃ³n significarÃ­a que la mÃ¡quina acepta w.
La idea de Cook y Levin era convertir el tablero en un conjunto de fÃ³rmulas booleanas de orden O(n^2k), por lo tanto se demostrarÃ­a que cualquier problema NP
puede reducirse en tiempo polinomial a un problema de satisfactibilidad (SAT) y, por lo tanto, SAT serÃ­a NP-Completo.



Teorema de Cook-Levin
Sea SAT el lenguaje formado por las fÃ³rmulas booleanas satisfactibles. El Teorema de Cook-Levin establece que SAT es NP-completo.

DemostraciÃ³n (idea):
Sea A un lenguaje perteneciente a NP. Entonces existe una MÃ¡quina de Turing no determinista N que decide A en tiempo polinomial n^k. Para una entrada w de longitud n, se construye un tablero de configuraciones de tamaÃ±o n^k x n^k, 
donde cada fila representa una configuraciÃ³n de la mÃ¡quina y las filas sucesivas corresponden a las transiciones de N.

Un tablero es aceptable si contiene una configuraciÃ³n que alcanza el estado de aceptaciÃ³n. Determinar si la mÃ¡quina N acepta la entrada w equivale a determinar si existe un tablero aceptable.

Este problema se transforma en un problema de satisfactibilidad construyendo una fÃ³rmula lÃ³gica
phi = phi_cell AND phi_start AND phi_move AND phi_accept,
donde phi_cell garantiza que en cada celda aparece un Ãºnico sÃ­mbolo, phi_start describe la configuraciÃ³n inicial, phi_move describe las transiciones vÃ¡lidas de la mÃ¡quina y phi_accept asegura que se alcanza un estado de aceptaciÃ³n.

La fÃ³rmula lÃ³gica resultante tiene tamaÃ±o O(n^(2k)), por lo que la transformaciÃ³n se realiza en tiempo polinomial. 
Por tanto, cualquier problema de NP puede reducirse en tiempo polinomial al problema SAT, y en consecuencia SAT es NP-completo.




/*
Demuestre que el problema CLIQUE es NP-Completo.
*/

Podemos demostrarlo si encontramos una reducciÃ³n del problema 3SAT a CLIQUE en tiempo polinomial.

Dada una fÃ³rmula-3cnf compuesta de k claÃºsulas (a âˆ¨ b âˆ¨ c), se puede construir un grafo G donde cada literal de cada claÃºsula genera un nodo y 
donde cada nodo estÃ¡ enlazado con todos los nodos del grafo excepto los de su clÃ¡usula y los contradictorios (por ejemplo, a y Ä).

Dada una fÃ³rmula con k claÃºsulas, el tamaÃ±o del grafo generado tendrÃ¡ 3k nodos y O(k^2) arcos. Por tanto se puede construir el grafo en un tiempo polinÃ³mico.

La fÃ³rmula es satisfactible si y solo si el grafo tiene un k-clique. Ese k-clique corresponde a la soluciÃ³n de la fÃ³rmula.
Es decir, si la variable booleana x aparece en el k-clique entonces la soluciÃ³n contiene el valor x=TRUE. Si el k-clique contiene la negaciÃ³n de x, entonces la soluciÃ³n contiene el valor x=FALSE.

Por tanto, el problema 3SAT se reduce en tiempo polinomial al problema CLIQUE, y se concluye que CLIQUE es NP-completo.





#### Bombeo ####

/*
Enuncie y demuestre el Lema de Bombeo para AutÃ³matas Finitos.
*/

Enunciado:
Sea L un lenguaje regular sobre el alfabeto E reconocido por un autÃ³mata finito determinista con m estados. Entonces, para toda cadena w perteneciente a L con longitud |w| â‰¥ m, 
existen cadenas r, s y t con |s| â‰¥ 1 y |rs| â‰¤ m tales que w = rst, y para todo n â‰¥ 0 se cumple que r s^n t pertenece a L.

DemostraciÃ³n:
Se demuestra utilizando el principio del palomar. Como el autÃ³mata tiene m estados diferentes y la cadena w tiene longitud |w| â‰¥ m, entonces existe al menos 1 estado repetido.
Esto implica que la subcadena s se puede â€œbombearâ€, es decir, el autÃ³mata tambiÃ©n podrÃ­a reconocer las cadenas: rt, rst, rsst, rssst.


/*
Enuncie y demuestre el Lema de Bombeo para AutÃ³matas de Pila.
*/

Enunciado:
Si L es un lenguaje libre de contexto, existe un p â‰¥ 1 tal que, toda cadena del lenguaje w de longitud mayor que p (|w|>p) puede escribirse como w = r s t u v, donde las subcadenas cumplen que:
â€“ | s t u | â‰¤ p
â€“ | s u | â‰¥ 1
â€“ r s^n t u^n v pertenece a L

DemostraciÃ³n:
Dado que la gramÃ¡tica libre de contexto tiene un nÃºmero de sÃ­mbolos No Terminales finito, si una cadena w es lo suficientemente larga, entonces en su Ã¡rbol
de derivaciÃ³n debe repetirse algÃºn sÃ­mbolo No Terminal N. Esto permite â€œbombearâ€ la derivaciÃ³n de N a N: N -> sNu -> ssNuu -> sstuu





##### Cuantica #####

/*
Â¿QuÃ© es un qubit?
*/

/*
Â¿QuÃ© es una puerta cuÃ¡ntica?
*/

/*
Enuncie y demuestre el teorema de no-clonaciÃ³n de qbits.
*/

/*
Describa el algoritmo de Deutsch de computaciÃ³n cuÃ¡ntica
*/






















