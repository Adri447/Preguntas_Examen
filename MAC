#### Complejidad ####

/*
¿Qué es un problema de clase P? 
*/

Un problema de clase P es un problema que es decidible en tiempo polinomial mediante una Máquina de Turing determinista de una cinta.

La clase P es invariante a los modelos de computacion que puedan simularse en tiempo polinomial en MT de una cinta.

/*
¿Qué es un problema de clase NP?
*/

Un problema de clase NP es un problema que es decidible en tiempo polinomial mediante una Máquina de Turing no determinista.


/*
¿Qué es un verificador de un lenguaje?
*/

Un verificador de un lenguaje es un algoritmo que permite saber si una cadena pertenece al lenguaje.
Es decir, una cadena w pertenece al lenguaje A si existe una cadena c tal que el algoritmo V acepta el par ⟨w,c⟩
A = {w ∣ V acepta ⟨w,c⟩ para alguna cadena c}

Un lenguaje A es verificable polinomialmente si existe un verificador en tiempo polinomial para A.



/*
Demuestre que un lenguaje A es NP si y solo si es verificable polinomialmente.
*/

Demostración: (<-)
Si A es verificable polinomialmente, entonces existe un verificador V en tiempo polinomial O(n^k). 
Podemos construir una Máquina de Turing indeterminista en tiempo polinomial de la siguiente forma:
Dada w de longitud n:
 1.- Generar de forma indeterminista una cadena c de longitud máxima n^k.
 2.- Ejecutar V sobre <w,c>
 3.- Si V acepta, aceptar. Si no, rechazar.


Demostración: (->)
Si A es NP entonces existe una Máquina de Turing no determinista que decide en tiempo polinomial O(n^k). 
Podemos construir un verificador V en tiempo polinomial O(n^k) de la siguiente forma:
Dadas <w,c> :
 1.- Ejecutar MT sobre w, tratando cada símbolo de c como la elección de cada paso indeterminista de MT.
 2.- Si el camino seleccionado por c acepta w, aceptar. Si no, rechazar.



/*
¿Qué es un lenguaje NP-Completo?
*/

Los problemas NP-completo son problemas NP que, si tuvieran solución en tiempo polinomial, permitirían demostrar que todos los problemas NP tienen solución en tiempo polinomial.
- Si algún problema NP no tiene solución polinomial, entonces ningún problema NP-completo tiene.
- Si algún problema NP-completo tiene solución polinomial, entonces todos los problemas NP tienen.



/*
Enuncie el Teorema de Cook y Levin y describa su demostración
*/

Sea SAT el lenguaje formado por las fórmulas booleanas satisfactibles, es decir, que existan valores que hacen cierta a la fórmula.
El Teorema de Cook y Levin establece que el lenguaje SAT pertenece a la clase P si y solo si P = NP. Es decir, SAT es un problema NP-Completo y por tanto 
existe un verificador que verifica SAT en tiempo polinomial (tabla de verdad).
El teorema plante un tablero de configuración en el que si se alcanza un estado de aceptación significaría que la máquina acepta w.
La idea de Cook y Levin era convertir el tablero en un conjunto de fórmulas booleanas de orden O(n^2k), por lo tanto se demostraría que cualquier problema NP
puede reducirse en tiempo polinomial a un problema de satisfactibilidad (SAT) y, por lo tanto, SAT sería NP-Completo.



Teorema de Cook-Levin
Sea SAT el lenguaje formado por las fórmulas booleanas satisfactibles, es decir, que existan valores que hacen cierta a la fórmula.
El Teorema establece que SAT es NP-completo. Es decir, pertenece a la clase P si y solo si P = NP.

Demostración (idea):
Sea A un lenguaje perteneciente a NP. Entonces existe una Máquina de Turing no determinista N que decide A en tiempo polinomial n^k. Para una entrada w de longitud n, se construye un tablero de configuraciones de tamaño n^k x n^k, 
donde cada fila representa una configuración de la máquina y las filas sucesivas corresponden a las transiciones de N.

Determinar si la máquina N acepta la entrada w equivale a determinar si existe un tablero aceptable. Un tablero es aceptable si contiene una configuración que alcanza el estado de aceptación. 

Este problema se transforma en un problema de satisfactibilidad construyendo una fórmula lógica
phi = phi_cell AND phi_start AND phi_move AND phi_accept, donde: 
phi_cell garantiza que en cada celda aparece un único símbolo
phi_start describe la configuración inicial
phi_move describe las transiciones válidas de la máquina 
phi_accept asegura que se alcanza un estado de aceptación

La fórmula lógica resultante tiene tamaño O(n^(2k)), por lo que la transformación se realiza en tiempo polinomial. 
Por tanto, cualquier problema de NP puede reducirse en tiempo polinomial al problema SAT, y en consecuencia SAT es NP-completo.




/*
Demuestre que el problema CLIQUE es NP-Completo.
*/

Podemos demostrarlo si encontramos una reducción del problema 3SAT a CLIQUE en tiempo polinomial.

Dada una fórmula-3cnf compuesta de k claúsulas (a ∨ b ∨ c), se puede construir un grafo G donde cada literal de cada claúsula genera un nodo y 
donde cada nodo está enlazado con todos los nodos del grafo excepto los de su cláusula y los contradictorios (por ejemplo, a y ā).

Dada una fórmula con k claúsulas, el tamaño del grafo generado tendrá 3k nodos y O(k^2) arcos. Por tanto se puede construir el grafo en un tiempo polinómico.

La fórmula es satisfactible si y solo si el grafo tiene un k-clique. Ese k-clique corresponde a la solución de la fórmula.
Es decir, si la variable booleana x aparece en el k-clique entonces la solución contiene el valor x=TRUE. Si el k-clique contiene la negación de x, entonces la solución contiene el valor x=FALSE.

Por tanto, el problema 3SAT se reduce en tiempo polinomial al problema CLIQUE, y se concluye que CLIQUE es NP-completo.





#### Bombeo ####

/*
Enuncie y demuestre el Lema de Bombeo para Autómatas Finitos.
*/

Enunciado:
Sea L un lenguaje regular sobre el alfabeto E reconocido por un autómata finito determinista con m estados. Entonces, para toda cadena w perteneciente a L con longitud |w| ≥ m, 
existen cadenas r, s y t con |s| ≥ 1 y |rs| ≤ m tales que w = rst, y para todo n ≥ 0 se cumple que r s^n t pertenece a L.

Demostración:
Se demuestra utilizando el principio del palomar. Como el autómata tiene m estados diferentes y la cadena w tiene longitud |w| ≥ m, entonces existe al menos 1 estado repetido.
Esto implica que la subcadena s se puede “bombear”, es decir, el autómata también podría reconocer las cadenas: rt, rst, rsst, rssst.


/*
Enuncie y demuestre el Lema de Bombeo para Autómatas de Pila.
*/

Enunciado:
Si L es un lenguaje libre de contexto, existe un p ≥ 1 tal que, toda cadena del lenguaje w de longitud mayor que p (|w|>p) puede escribirse como w = r s t u v, donde las subcadenas cumplen que:
– | s t u | ≤ p
– | s u | ≥ 1
– r s^n t u^n v pertenece a L

Demostración:
Dado que la gramática libre de contexto tiene un número de símbolos No Terminales finito, si una cadena w es lo suficientemente larga, entonces en su árbol
de derivación debe repetirse algún símbolo No Terminal N. Esto permite “bombear” la derivación de N a N: N -> sNu -> ssNuu -> sstuu





##### Cuantica #####

/*
¿Qué es un qubit?
*/

Un qubit es la unidad básica de información en la teoría cuántica de la información, representado por un estado cuántico en un espacio de Hilbert bidimensional. 
Este espacio tiene una base ortonormal formada por dos estados, |0> y |1>, y cualquier qubit puede expresarse como una combinación lineal a0|0> + a1|1>, 
donde a0 y a1 son números complejos cuya suma de los cuadrados de sus módulos es 1 para asegurar la normalización del estado.


/*
¿Qué es una puerta cuántica?
*/

Una puerta cuántica es un dispositivo que permite transformar el estado de uno o varios qubits. 
Matemáticamente, se describe como un operador lineal que actúa sobre el estado cuántico, y por tanto se puede representar en forma matricial.



/*
Enuncie y demuestre el teorema de no-clonación de qbits.
*/

Teorema de No-Clonación:
Es imposible copiar un estado cuántico desconocido de manera exacta.

Demostración:
Matemáticamente podemos demostrar este teorema considerando un sistema de dos qubits donde queremos generar una copia del primer qubit sobre el segundo.

Supongamos que tenemos un qubit arbitrario |ψ⟩ = a∣0⟩ + b∣1⟩ que queremos clonar y un segundo qubit inicializado en |0>. 
Queremos un operador C tal que 
C(|0> ⊗ |0>) = |0> ⊗ |0>.
C(|1> ⊗ |0>) = |1> ⊗ |1>. 
C((a∣0⟩ + b∣1⟩) ⊗ ∣0⟩) = (a∣0⟩ + b∣1⟩) ⊗ (a∣0⟩ + b∣1⟩).

Los dos primeros resultados se refieren a la clonación de los estados de la base. Aplicando la linealidad de los operadores cuántico,s el resultado en el caso general sería
C((a|0> + b|1>) ⊗ |0>) = a(|0> ⊗ |0>) + b(|1> ⊗ |1>). 

Por tanto es imposible que el operador C genere el resultado deseado para el caso general.

Conclusión:
No es posible construir un clon exacto de un qubit desconocido, reflejando la imposibilidad de copiar información cuántica sin alterarla y relacionándose con el principio de incertidumbre.



/*
Describa el algoritmo de Deutsch de computación cuántica
*/

Algoritmo de Deutsch

El algoritmo de Deutsch es uno de los primeros algoritmos de computación cuántica que muestra cómo un ordenador cuántico puede resolver un problema más rápido que uno clásico. 
El problema consiste en determinar si una función booleana f: {0,1} → {0,1} es constante (devuelve el mismo valor para ambas entradas) o balanceada (devuelve valores diferentes para las dos entradas).

Descripción del algoritmo:

Se preparan dos qubits:
El primero en el estado |0⟩
El segundo en el estado |1⟩

Se aplican puertas Hadamard (H) a ambos qubits, creando superposiciones:
El primer qubit queda en (|0⟩ + |1⟩)/√2
El segundo en (|0⟩ - |1⟩)/√2

Se aplica el operador cuántico Uf que codifica la función f, actuando sobre los dos qubits y modificando el estado según f.
Se aplica otra puerta Hadamard al primer y segundo qubit.

Se mide el primer qubit:
Si el resultado es 0, la función f es constante.
Si el resultado es 1, la función f es balanceada.

Ventaja cuántica:
El algoritmo determina la propiedad de la función con una sola evaluación de f, mientras que un algoritmo clásico necesitaría evaluar f(0) y f(1) para decidir.






















