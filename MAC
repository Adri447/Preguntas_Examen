#### Complejidad ####

/*
¬øQu√© es un problema de clase P?   // No es lo mismo lenguaje que problema
*/

Un problema de clase P es un problema que es decidible en tiempo polinomial mediante una M√°quina de Turing determinista de una cinta.
Dado un lenguaje ùêø, existe una M√°quina de Turing determinista que decide si una cadena ùë§ pertenece a ùêø en tiempo polinomial.

La clase P es invariante a los modelos de computacion que puedan simularse en tiempo polinomial en MT de una cinta.

/*
¬øQu√© es un problema de clase NP?
*/

Un problema de clase NP es un problema que es decidible en tiempo polinomial mediante una M√°quina de Turing no determinista.


/*
¬øQu√© es un verificador de un lenguaje?
*/

Un verificador de un lenguaje es un algoritmo que permite saber si una cadena pertenece al lenguaje.
Es decir, una cadena w pertenece al lenguaje A si existe una cadena c tal que el algoritmo V acepta el par ‚ü®w,c‚ü©
A = {w ‚à£ V acepta ‚ü®w,c‚ü© para alguna cadena c}

Un lenguaje A es verificable polinomialmente si existe un verificador en tiempo polinomial para A.



/*
Demuestre que un lenguaje A es NP si y solo si es verificable polinomialmente.
*/

Demostraci√≥n: (<-)
Si A es verificable polinomialmente, entonces existe un verificador V en tiempo polinomial O(n^k). 
Podemos construir una M√°quina de Turing indeterminista en tiempo polinomial de la siguiente forma:
Dada w de longitud n:
 1.- Generar de forma indeterminista una cadena c de longitud m√°xima n^k.
 2.- Ejecutar V sobre <w,c>
 3.- Si V acepta, aceptar. Si no, rechazar.


Demostraci√≥n: (->)
Si A es NP entonces existe una M√°quina de Turing no determinista que decide en tiempo polinomial O(n^k). 
Podemos construir un verificador V en tiempo polinomial O(n^k) de la siguiente forma:
Dadas <w,c> :
 1.- Ejecutar MT sobre w, tratando cada s√≠mbolo de c como la elecci√≥n de cada paso indeterminista de MT.
 2.- Si el camino seleccionado por c acepta w, aceptar. Si no, rechazar.



/*
¬øQu√© es un lenguaje NP-Completo?
*/

Los problemas NP-completo son problemas NP que, si tuvieran soluci√≥n en tiempo polinomial, permitir√≠an demostrar que todos los problemas NP tienen soluci√≥n en tiempo polinomial.
- Si alg√∫n problema NP no tiene soluci√≥n polinomial, entonces ning√∫n problema NP-completo tiene.
- Si alg√∫n problema NP-completo tiene soluci√≥n polinomial, entonces todos los problemas NP tienen.



/*
Enuncie el Teorema de Cook y Levin y describa su demostraci√≥n
*/

Sea SAT el lenguaje formado por las f√≥rmulas booleanas satisfactibles, es decir, que existan valores que hacen cierta a la f√≥rmula.
El Teorema de Cook y Levin establece que el lenguaje SAT pertenece a la clase P si y solo si P = NP. Es decir, SAT es un problema NP-Completo y por tanto 
existe un verificador que verifica SAT en tiempo polinomial (tabla de verdad).
El teorema plante un tablero de configuraci√≥n en el que si se alcanza un estado de aceptaci√≥n significar√≠a que la m√°quina acepta w.
La idea de Cook y Levin era convertir el tablero en un conjunto de f√≥rmulas booleanas de orden O(n^2k), por lo tanto se demostrar√≠a que cualquier problema NP
puede reducirse en tiempo polinomial a un problema de satisfactibilidad (SAT) y, por lo tanto, SAT ser√≠a NP-Completo.



Teorema de Cook-Levin
Sea SAT el lenguaje formado por las f√≥rmulas booleanas satisfactibles. El Teorema establece que SAT es NP-completo.

Demostraci√≥n (idea):
Sea A un lenguaje perteneciente a NP. Entonces existe una M√°quina de Turing no determinista N que decide A en tiempo polinomial n^k. Para una entrada w de longitud n, se construye un tablero de configuraciones de tama√±o n^k x n^k, 
donde cada fila representa una configuraci√≥n de la m√°quina y las filas sucesivas corresponden a las transiciones de N.

Determinar si la m√°quina N acepta la entrada w equivale a determinar si existe un tablero aceptable. Un tablero es aceptable si contiene una configuraci√≥n que alcanza el estado de aceptaci√≥n. 

Este problema se transforma en un problema de satisfactibilidad construyendo una f√≥rmula l√≥gica
phi = phi_cell AND phi_start AND phi_move AND phi_accept, donde: 
phi_cell garantiza que en cada celda aparece un √∫nico s√≠mbolo
phi_start describe la configuraci√≥n inicial
phi_move describe las transiciones v√°lidas de la m√°quina 
phi_accept asegura que se alcanza un estado de aceptaci√≥n

La f√≥rmula l√≥gica resultante tiene tama√±o O(n^(2k)), por lo que la transformaci√≥n se realiza en tiempo polinomial. 
Por tanto, cualquier problema de NP puede reducirse en tiempo polinomial al problema SAT, y en consecuencia SAT es NP-completo.




/*
Demuestre que el problema CLIQUE es NP-Completo.
*/

Podemos demostrarlo si encontramos una reducci√≥n del problema 3SAT a CLIQUE en tiempo polinomial.

Dada una f√≥rmula-3cnf compuesta de k cla√∫sulas (a ‚à® b ‚à® c), se puede construir un grafo G donde cada literal de cada cla√∫sula genera un nodo y 
donde cada nodo est√° enlazado con todos los nodos del grafo excepto los de su cl√°usula y los contradictorios (por ejemplo, a y ƒÅ).

Dada una f√≥rmula con k cla√∫sulas, el tama√±o del grafo generado tendr√° 3k nodos y O(k^2) arcos. Por tanto se puede construir el grafo en un tiempo polin√≥mico.

La f√≥rmula es satisfactible si y solo si el grafo tiene un k-clique. Ese k-clique corresponde a la soluci√≥n de la f√≥rmula.
Es decir, si la variable booleana x aparece en el k-clique entonces la soluci√≥n contiene el valor x=TRUE. Si el k-clique contiene la negaci√≥n de x, entonces la soluci√≥n contiene el valor x=FALSE.

Por tanto, el problema 3SAT se reduce en tiempo polinomial al problema CLIQUE, y se concluye que CLIQUE es NP-completo.





#### Bombeo ####

/*
Enuncie y demuestre el Lema de Bombeo para Aut√≥matas Finitos.
*/

Enunciado:
Sea L un lenguaje regular sobre el alfabeto E reconocido por un aut√≥mata finito determinista con m estados. Entonces, para toda cadena w perteneciente a L con longitud |w| ‚â• m, 
existen cadenas r, s y t con |s| ‚â• 1 y |rs| ‚â§ m tales que w = rst, y para todo n ‚â• 0 se cumple que r s^n t pertenece a L.

Demostraci√≥n:
Se demuestra utilizando el principio del palomar. Como el aut√≥mata tiene m estados diferentes y la cadena w tiene longitud |w| ‚â• m, entonces existe al menos 1 estado repetido.
Esto implica que la subcadena s se puede ‚Äúbombear‚Äù, es decir, el aut√≥mata tambi√©n podr√≠a reconocer las cadenas: rt, rst, rsst, rssst.


/*
Enuncie y demuestre el Lema de Bombeo para Aut√≥matas de Pila.
*/

Enunciado:
Si L es un lenguaje libre de contexto, existe un p ‚â• 1 tal que, toda cadena del lenguaje w de longitud mayor que p (|w|>p) puede escribirse como w = r s t u v, donde las subcadenas cumplen que:
‚Äì | s t u | ‚â§ p
‚Äì | s u | ‚â• 1
‚Äì r s^n t u^n v pertenece a L

Demostraci√≥n:
Dado que la gram√°tica libre de contexto tiene un n√∫mero de s√≠mbolos No Terminales finito, si una cadena w es lo suficientemente larga, entonces en su √°rbol
de derivaci√≥n debe repetirse alg√∫n s√≠mbolo No Terminal N. Esto permite ‚Äúbombear‚Äù la derivaci√≥n de N a N: N -> sNu -> ssNuu -> sstuu





##### Cuantica #####

/*
¬øQu√© es un qubit?
*/

Un qubit es la unidad b√°sica de informaci√≥n en la teor√≠a cu√°ntica de la informaci√≥n, representado por un estado cu√°ntico en un espacio de Hilbert bidimensional. 
Este espacio tiene una base ortonormal formada por dos estados, |0> y |1>, y cualquier qubit puede expresarse como una combinaci√≥n lineal a0|0> + a1|1>, 
donde a0 y a1 son n√∫meros complejos cuya suma de los cuadrados de sus m√≥dulos es 1 para asegurar la normalizaci√≥n del estado.


/*
¬øQu√© es una puerta cu√°ntica?
*/

Una puerta cu√°ntica es un dispositivo que permite transformar el estado de uno o varios qubits. 
Matem√°ticamente, se describe como un operador lineal que act√∫a sobre el estado cu√°ntico, y por tanto se puede representar en forma matricial.



/*
Enuncie y demuestre el teorema de no-clonaci√≥n de qbits.
*/

Teorema de No-Clonaci√≥n:
Es imposible copiar un estado cu√°ntico desconocido de manera exacta.

Demostraci√≥n:
Matem√°ticamente podemos demostrar este teorema considerando un sistema de dos qubits donde queremos generar una copia del primer qubit sobre el segundo.

Supongamos que tenemos un qubit arbitrario |œà‚ü© = a‚à£0‚ü© + b‚à£1‚ü© que queremos clonar y un segundo qubit inicializado en |0>. 
Queremos un operador C tal que 
C(|0> ‚äó |0>) = |0> ‚äó |0>.
C(|1> ‚äó |0>) = |1> ‚äó |1>. 
C((a‚à£0‚ü© + b‚à£1‚ü©) ‚äó ‚à£0‚ü©) = (a‚à£0‚ü© + b‚à£1‚ü©) ‚äó (a‚à£0‚ü© + b‚à£1‚ü©).

Los dos primeros resultados se refieren a la clonaci√≥n de los estados de la base. Aplicando la linealidad de los operadores cu√°ntico,s el resultado en el caso general ser√≠a
C((a|0> + b|1>) ‚äó |0>) = a(|0> ‚äó |0>) + b(|1> ‚äó |1>). 

Por tanto es imposible que el operador C genere el resultado deseado para el caso general.

Conclusi√≥n:
No es posible construir un clon exacto de un qubit desconocido, reflejando la imposibilidad de copiar informaci√≥n cu√°ntica sin alterarla y relacion√°ndose con el principio de incertidumbre.



/*
Describa el algoritmo de Deutsch de computaci√≥n cu√°ntica
*/

Algoritmo de Deutsch

El algoritmo de Deutsch es uno de los primeros algoritmos de computaci√≥n cu√°ntica que muestra c√≥mo un ordenador cu√°ntico puede resolver un problema m√°s r√°pido que uno cl√°sico. 
El problema consiste en determinar si una funci√≥n booleana f: {0,1} ‚Üí {0,1} es constante (devuelve el mismo valor para ambas entradas) o balanceada (devuelve valores diferentes para las dos entradas).

Descripci√≥n del algoritmo:

Se preparan dos qubits:
El primero en el estado |0‚ü©
El segundo en el estado |1‚ü©

Se aplican puertas Hadamard (H) a ambos qubits, creando superposiciones:
El primer qubit queda en (|0‚ü© + |1‚ü©)/‚àö2
El segundo en (|0‚ü© - |1‚ü©)/‚àö2

Se aplica el operador cu√°ntico Uf que codifica la funci√≥n f, actuando sobre los dos qubits y modificando el estado seg√∫n f.
Se aplica otra puerta Hadamard al primer y segundo qubit.

Se mide el primer qubit:
Si el resultado es 0, la funci√≥n f es constante.
Si el resultado es 1, la funci√≥n f es balanceada.

Ventaja cu√°ntica:
El algoritmo determina la propiedad de la funci√≥n con una sola evaluaci√≥n de f, mientras que un algoritmo cl√°sico necesitar√≠a evaluar f(0) y f(1) para decidir.






















